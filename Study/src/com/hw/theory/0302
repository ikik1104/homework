
	<<20.03.02>>
	
	1) Vector

 --	Vector 예전버전 (잘 안쓰는 편) / ArrayList 최근버전  ----->> 거의 똑같다! 이름만 다를 뿐.
 	(10개씩 만들어낸다 )
	
	멀티 스레드 지원  - 백터
	지원 안된다 - arrayList
	
 --	Vector<E> vec = new Vector<E>();
	<E> - e 말고 다른 형이 들어올 수 없게 / 만약 아무거나 들어가도 상관이 없다면 사용하지 않아도 된다.
	
	ex1) Vector<Product> vec = new Vector<Product>(); -> Product와 다른 제품이 들어가면 오류가 난다.
	ex2) Vector vec = new Vector(); Object로 들어가서 아무거나 다~~ 들어간다. 
	
 -- 배열을 다 arrayList로 쓰자~!
    > no~! 문제는 없으나 작은 배열을 쓸때는 빠르고 가벼운 배열을 쓰자.
    > 객체를 사용하면 프로그램이 무거워진짜 (객체 자체를 배열로 사용해야한다고 무조건 사용해야한다.)
    > 객체 한두개 사용하려면 그냥 객체 (Student[3])로 사용하는게 좋다.
    
    
    *(추상클래스, 인터페이스 - 상속받아서 완성시켜야한다.)
    
    2) 추상클래스 ( abstract class ) -상속을해서 완성시켜야한다.
    	* 추상메서드를 하나라도 가지고 있는 클래스를 추상클래스라고 한다.
    	** 선언부만 있고 구현부({내용})가 없는 메서드
    	- 미완성 설계도
    	- 객체선언 불가능
    	- 일반 메서드가 추상메서드를 호출할 수 있다.
    	만드는 이유 : 메서드명을 통일하거나, 꼭 필요한 메서드를 정의내려줄때...?
    			 일부만 제작해놓고 사용할 수 있게 해놓는..?
    			 
    3) 인터페이스
    	상속받아서 구현을 완성시켜줘야한다.
		extends가 아닌 implements(구현)를 사용한다

    	- 상속받는 곳에서구현을 해야지만 완성
    	- 구현된게 전혀없는 기본 설계도
    	- 추상메서드와 상수만 멤버로 가질 수 있다.
    	- 인스턴스를 생성할 수 없고, 클래스작성에 도움을 줄 목적으로 사용된다.
    	만드는 이유 : 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하는데 사용된다.
				  메소드의 명을 동일화 시켜주기 위해
		Object 클래스를 상속받지 않는다.
		** 변수에서는 무조건 public static final
		** 메소드에서는 public abstract을 사용해야하지만..,!
			----> 생략하면 알아서 붙여준다.    	
		- 다중 상속 가능 
		
		- 두 대상(객체) 간의 '연결, 대화,소통'을 돕는 중간역할을 한다.
		- 선언(설계)와 구현을 분히시키는 것을 가능하게 한다.
		
		
    	
    	
    	
    	